# 01 - Java基础
	围绕Java语言基本特性和机制，构建牢固的Java技术功底。

---

# Lesson1 谈谈你对Java平台的理解？
	对于这类笼统的问题，你需要尽量表现出自己的思维深入并系统化，Java 知识理解得也比较全面。
	毕竟明白基本组成和机制，是日常工作中进行问题诊断或者性能调优等很多事情的基础。

##### 问一、谈谈你对 Java 平台的理解？
	从以下几个方面展开：
		1、Java语言的基础功能和重要特性
		2、JVM的运行机制
		3、JVM平台

###### 1) Java语言的特征
	Java 本身是一种面向对象的语言；

	最显著的特性有两个方面（与JVM密切相关）：
	
	一是所谓的“书写一次，到处运行（Write once, run anywhere）”，能够非常容易地获得跨平台能力；
	
	另外就是垃圾收集（GC, Garbage Collection）
	Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。

###### 2) JRE与JDK的关系
	JRE，也就是 Java 运行环境，包含了 JVM 和 Java 类库，以及一些模块等。
	
	JDK，可以看作是 JRE 的一个超集，提供了更多工具，比如编译器、各种诊断工具等。
	JDK 包含的工具或者 Java 领域内其他第三方工具等
		如编译器、运行时环境、安全工具、诊断和监控工具等。
		这些基本工具是日常工作效率的保证，对于我们工作在其他语言平台上，同样有所帮助，很多都是触类旁通的。


###### 3)Java语言的基础组成和特性
	基础类库，包括集合、IO/NIO、网络、并发、安全等基础类库。
	日常工作应用较多的类库，比如第三方工具型类库：apache-commons,guava,fastjson
	Java 语言特性，包括泛型、Lambda、函数式编程 等语言特性
![](img/java-platform.png)

###### 4) JVM类加载器与加载流程
	谈谈 JVM 的一些基础概念和机制，比如 Java 的类加载机制，常用版本 JDK（如 JDK 8）内嵌的 Class-Loader
	例如 Bootstrap、 Application 和 Extension Class-loader；
	
	类加载大致过程：加载、验证、链接、初始化、卸载。
	
	自定义 Class-Loader
		自定义Class-Loader如何实现？
		什么情况下需要自定义Class-Loader？

###### 5) JVM垃圾回收
	还有垃圾收集的基本原理，最常见的垃圾收集器，如 SerialGC、Parallel GC、 CMS、 G1 等，
	对于适用于什么样的工作负载最好也心里有数。
	
###### 6) JVM支持的编译方式
众所周知，我们通常把 Java 分为编译期和运行时。

这里说的 Java 的编译和 C/C++ 是有着不同的意义的，Javac 的编译，编译 Java 源码生成“.class”文件里面实际是字节码，而不是可以直接执行的机器码。

Java 通过字节码和 Java 虚拟机（JVM）这种跨平台的抽象，屏蔽了操作系统和硬件的细节，这也是实现“一次编译，到处执行”的基础。	

	1、解释执行 -Xint -Xcomp
		Java 虚拟机启动时，可以指定不同的参数对运行模式进行选择。 
		比如，指定“-Xint”，就是告诉 JVM 只进行解释执行，不对代码进行编译
		这种模式抛弃了 JIT 可能带来的性能优势。毕竟解释器（interpreter）是逐条读入，逐条解释运行的。
		与其相对应的，还有一个“-Xcomp”参数，这是告诉 JVM 关闭解释器，不要进行解释执行，或者叫作最大优化级别。
		那你可能会问这种模式是不是最高效啊？
		简单说，还真未必。
		“-Xcomp”会导致 JVM 启动变慢非常多，
		同时有些 JIT 编译器优化方式，比如分支预测，如果不进行 profiling，往往并不能进行有效优化。

	2、JIT（Just-In-Time Compiler） 动态编译器
		在运行时，JVM 会通过类加载器（Class-Loader）加载字节码，解释或者编译执行。
		主流 Java 版本中，如 JDK 8 实际是解释和编译混合的一种模式，即所谓的混合模式（-Xmixed）。
		通常运行在 server 模式的 JVM，会进行上万次调用以收集足够的信息进行高效的编译，client 模式这个门限是 1500 次。
		Oracle Hotspot JVM 内置了两个不同的 JIT compiler，C1 对应前面说的 client 模式，适用于对于启动速度敏感的应用，比如普通 Java 桌面应用；
		C2 对应 server 模式，它的优化是为长时间运行的服务器端应用设计的。
		默认是采用所谓的分层编译（TieredCompilation）。

	3、AOT（Ahead-of-Time Compilation） 预编译器
		AOT是一种新的编译方式
		直接将字节码编译成机器代码，这样就避免了 JIT 预热等各方面的开销，
		比如 Oracle JDK 9 就引入了实验性的 AOT 特性，并且增加了新的 jaotc 工具。
		利用命令把某个类或者某个模块编译成为 AOT 库。

###### JVM是一个平台，并非Java语言所独占
	JVM 作为一个强大的平台，不仅仅只有 Java 语言可以运行在 JVM 上
	本质上合规的字节码都可以运行，Java 语言自身也为此提供了便利
	类似 Clojure、Scala、Groovy、JRuby、Jython 等大量 JVM 语言，活跃在不同的场景。


---
#### 问二、“Java 是解释执行”，这句话正确吗？
	从JVM所支持的几种运行模式展开：解释执行、即时编译、混合模式

####### 1) 对于“Java 是解释执行”这句话，这个说法不太准确。
	我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），
	然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。
	但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器。
	JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。
