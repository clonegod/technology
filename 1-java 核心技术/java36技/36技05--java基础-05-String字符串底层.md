# Lesson 5 | 理解Java中的String字符串 

几乎所有的应用开发都离不开操作字符串。

理解字符串的设计和实现以及相关工具如拼接类的使用，对写出高质量代码是非常有帮助的。


# String、StringBuffer、StringBuilder有什么区别？

	> String 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。
	它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。
	也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。
	由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。

	> StringBuffer 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，
	它是 Java 1.5 中新增的，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。
	StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，
	也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，
	也就是 StringBuilder。	

	> StringBuilder 在能力上和 StringBuffer 没有本质区别，
	但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。

## String 基本特质 
	String 是 Immutable 的
	字符串操作不当可能会产生大量临时字符串

## String为什么要设计为不可变的？
	由于String字符串的操作在代码中出现非常频繁，以降低多线程并发安全设计的复杂性，
	因此将String设计为不可变的，这样就能保证多线程操作的安全。
	不可变性在多线程并发设计中也是一种设计模式的应用。

-------
## 知识扩展

### 1. 字符串设计和实现考量
	String 是 Immutable 类的典型实现，原生的保证了基础线程安全，
	因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，
	由于不可变，Immutable 对象在拷贝时不需要额外复制数据。

	StringBuffer 实现的一些细节，它的线程安全是通过把各种修改数据的方法都加上 synchronized 关键字实现的，非常直白。
	其实，这种简单粗暴的实现方式，非常适合我们常见的线程安全类实现，不必纠结于 synchronized 性能之类的，
	> 有人说“过早优化是万恶之源”，考虑可靠性、正确性和代码可读性才是大多数应用开发最重要的因素。
	
	为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，
	二者都继承了 AbstractStringBuilder，里面包含了基本操作，
	区别仅在于最终的方法是否加了 synchronized。


###### 字符串内部的字符数组
	字符串内部维护的char数组应该创建成多大的呢？
	如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。
	目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。
	我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。
	扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 arraycopy。

---
# Java底层对字符串的优化
	在 JDK 8 中，字符串拼接操作会自动被 javac 转换为 StringBuilder 操作，
	而在 JDK 9 里面则是因为 Java 9 为了更加统一字符串操作优化，
	提供了 StringConcatFactory，作为一个统一的入口。
	javac 自动生成的代码，虽然未必是最优化的，但普通场景也足够了

### 2. 字符串缓存
	粗略统计过，把常见应用进行堆转储（Dump Heap），然后分析对象组成，会发现平均 25% 的对象是字符串，并且其中约半数是重复的。
	如果能避免创建重复字符串，可以有效降低内存消耗和对象创建开销。

	String 在 Java 6 以后提供了 intern() 方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。
	在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。
	一般来说，JVM 会将所有的类似“abc”这样的文本字符串，或者字符串常量之类缓存起来。
	
###### 字符串缓存的intern机制
	一般使用 Java 6 这种历史版本，并不推荐大量使用 intern，为什么呢？
	魔鬼存在于细节中，被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，
	这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到。
	所以，如果使用不当，OOM 就会光顾。
	
	在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，
	甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。
	而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。
	你可以使用下面的参数直接打印具体数字，可以拿自己的 JDK 立刻试验一下。
		-XX:+PrintStringTableStatistics

###### String.intern()
	Intern 是一种显式地排重机制，但是它也有一定的副作用，
	因为需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的；
	另外就是我们很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为这是一种污染代码的实践。

	幸好在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是 G1 GC 下的字符串排重。
	它是通过将相同数据的字符串指向同一份数据来做到的，是 JVM 底层的改变，并不需要 Java 类库做什么修改。
	注意这个功能目前是默认关闭的，你需要使用下面参数开启，并且记得指定使用 G1 GC：
		-XX:+UseStringDeduplication



### 3.String 自身的演化
	如果你仔细观察过 Java 的字符串，在历史版本中，它是使用 char 数组来存数据的，这样非常直接。
	但是 Java 中的 char 是两个 bytes 大小，拉丁语系语言的字符，根本就不需要太宽的 char，这样无区别的实现就造成了一定的浪费。
	密度是编程语言平台永恒的话题，因为归根结底绝大部分任务是要来操作数据的。

	其实在 Java 6 的时候，Oracle JDK 就提供了压缩字符串的特性，
	但是这个特性的实现并不是开源的，而且在实践中也暴露出了一些问题，
	所以在最新的 JDK 版本中已经将它移除了。

	在 Java 9 中，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。
	将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，
	并且将相关字符串操作类都进行了修改。
	另外，所有相关的 Intrinsic 之类也都进行了重写，以保证没有任何性能损失。

	虽然底层实现发生了这么大的改变，但是 Java 字符串的行为并没有任何大的变化，
	所以这个特性对于绝大部分应用来说是透明的，绝大部分情况不需要修改已有代码。

	





    
